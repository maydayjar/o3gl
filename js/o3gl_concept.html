<script>
/*
	program.
	Set("uP",1,0,0).
	Set("aV", ab.pointer().stride(0).offset(0)).			
	Set("sampler", t1).

	Color(t1.level(0)).
	Depth(depthBuffer).depthMask(true).depthTest(true).
	Elements(elementArray)
	DrawTriangles(indexes, 0, 6).toFrameBuffer(frameBuffer);
*/

/*
	Program - is executable code
	instance 	- pointer to drawcall data. vao 
				- 
	
*/

/*
// GL object groups concept
- Programs with precompiled shaders
- Vertex Array Object
- Frame Buffer objects

*/

/*
// OBJECT concept
- Has assotiated VAO and UAO that are applied to any program within
- elements array
- first and count
- draw mode 
- Can have one or more 'methods' that are programs
- Can be 'abstract' and extended
- Every method is passed it's output (textures, depthBuffer)

o3gl.createObject().

// Entities
Geometry 
	VAO
	Elements
	first/last

Geometry Assembly
	Triangle
	Line
	Point
	
	
Rasterize
	inputs
		DepthTest
		StencilTest
		Blend 

	outputs
		FrameBuffer
			RenderBuffers 
				Color
				Depth
				Stencil
		
	Viewport
	glDrawMode
	

Program
	DepthTest
	StencilTest
	unitforms
	

// PIPELINE concept

Vertices > Vertex shader > Primitives generation > Rasterization > Fragment shader > Testing/Blending > Framebuffer
o3gl.pipeline().
	vertices(vertexShader).
		elements(buffer).
		set("a1", arrayBuffer.pointer()).
		set("a2", arrayBuffer.pointer()).
	rasterization(fragmentShader).
		first(0).count(6)
		modeTriangleFan()
		modePoints(pointSize)
		modeLines(lineWidth)
		
	
	primitivesGeneration().
	rasterization()
	
// DRAWCALL concept

o3gl.
	drawcall().
	program(program).
	vertexArrayObject(abo).
	frameBufferObject(fbo).
	set("a", vertexes).
	elements(buffer).
	drawTriangles().
	first(0).
	last(100).
	renderBufferColor(texture1, texture2).
	renderBufferDepth().
	depthTest(true).
	depthMask(true).
	viewport()
	

// IMPLICIT INSTANCING concept
Some of the chained methods produce a new program instance 

// EXPLICIT INSTANCING concept
Explicit program instance creation


*/

/**
TODO:

- hints sucks. must be changed to inheritance or some kind of builder pattern

	
- Program instancing
	- Program globals are bound to program and used implicitly (if set)
		- Global uniforms (default) (implemented by default)
		- Global attributes (default) (implemented)
			- Shortcut (VAO) lazy initialization methods (Set, AttributeXX, VertexAttributeXX,  VertexAttributePointer)
		- Global FrameBufferObject
			- Shortcut (FBO) lazy initialization methods (Set, AttributeXX, VertexAttributeXX,  VertexAttributePointer)

	- Instancing implies usage of global values that are substituted when new value is assigned
		- Uniform Buffer Object (per instance)		
		- Vertex Array Objects (per instance)		
		- FrameBufferObject (per instance). 		Do we really need it???
		
	- Internally generated resources (It is likely a bad idea, can have problems with configuration !!! )
		- Deleted when the program resource is deleted
		- Both for globals and in
		- textures, (sampler2D/samplerCube), )

	- Embedded matrix operations
		```
			mat4.identity(matrixM);
			mat4.translate(matrixM, [x * step, y * step, z * step]);			
			mat4.multiply(matrixV, matrixM , matrixMV);
			mat4.toInverseMat3(matrixMV, matrixN);
			mat3.transpose(matrixN);
			programPhong.
				Set("uMatrixV", 	matrixV). 		
				Set("uMatrixP", 	matrixP).		
				Set("uMatrixM", 	matrixM).
				Set("uMatrixN", 	matrixN).
		```
		```
			// Internal stack
			programPhong.matrix("uMatrixV").identity().lookat();
			programPhong.matrix("uMatrixM").identity().translate(1, 0, 0);
			programPhong. matrix("uMatrixV").multiply("uMatrixM").toInverseMat3().transpose().Set("uMatrixN");
		```
		
	
- aspects

	- layered concept (based on aspects)
		- client state tracking. Automatic `Use` and `Bind` methods invokation
		- or deffered methods that are used right after `Use` or `Bind` methods invoked. this allows configuration reordering. The cases are:
			- Any ideas???

		
- methods and variables naming convention


- Inline compillation / scripts generation. Killer feature!

*/

/**
program.VertexArray(); 				// return default
program.VertexArray(customVAO); 		// set up new
program.FrameBuffer();				// default frame buffer
program.FrameBuffer(null);				// default frame buffer
program.FrameBuffer(custom FBO);		// default frame buffer

program.FrameBuffer().Color(texture0, texture1);
program.FrameBuffer().Depth(texture2);		// Depth texture extension
program.FrameBuffer().Stencil(rbDepth);		// Depth texture extension DepthMask(true)
program.FrameBuffer().Clear(); // Clear all the assotiated buffers

program.FrameBuffer().ClearColor(0,0,0,1);
program.FrameBuffer().ClearColor(false);
program.FrameBuffer().ClearDepth(1.0);
program.FrameBuffer().ClearDepth(false);
program.FrameBuffer().Clear();					// By default clears all the assotiated render buffers with the default value. 
program.FrameBuffer().ClearColorBuffer();		
program.FrameBuffer().ClearDepthBuffer();
program.FrameBuffer().ClearStencilBuffer();

program.DepthTest(true);		// Depth test and mask are program-specific features
program.DepthMask(true);		// Depth test and mask are program-specific features 


*/



















/*
new Aspect(o3gl.FrameBufferDefault).
deffer(
	function() {
		return isBound
	}
	,
	"Viewport",
	"ClearColorBuffer",
	"ClearDepthBuffer",
	"Clear",
	"DepthMask",
	"DepthTest",
	"ColorMask",
	"SetClearColor",
	"SetClearDepth",
	
)


"Viewport",
"ClearColorBuffer",
"ClearDepthBuffer",
"Clear",
"DepthMask",
"DepthTest",
"ColorMask",
"SetClearColor",
"SetClearDepth"
)
*/

/**
new Aspect(o3gl.Program.prototype).
deffer("Set", "isUsed").
after("Use").triggerDeffered()


deffered(o3gl.Program.prototype).
methods("Set").
condition("isUsed").
triggerAfter("Use")


deffered(
	o3gl.Program.prototype,
	"Set", 
	"isUsed",
)


if (this.isUsed()) {
	method();
} else {
	
}

*/

// Aspect builder
/*
	aspect(o).method(function(){}).before("f1");
	aspect(o).method(function(){}).before("f1");
	
	aspect(o).deffer("Data").ifFalse("isBound").after("Bind");
	
	
	aspect(o).
*/


function Aspect(object) {
	var _object = object;
	var _deffered = [];
	
	return {
		advice : function(methodName, adviceBefore, adviceAfter) {
			var method = _object[methodName];
			// Wrapped
			_object[methodName] = function() {
				var args = arguments;
				if (adviceBefore) {
					adviceBefore.apply(this, args);					
				}
				var result = method.apply(this, args);
				if (adviceAfter) {
					adviceAfter.apply(this, args);					
				}
				return result;
			}	
			return this;
		}
		,
		
		before : function(methodNameRegExp, advice) {			
			if (methodNameRegExp instanceof String) {
				methodNameRegExp = new RegExp(methodNameRegExp);
			}
			for (var propertyName in _object) {
				if (!propertyName.match(methodNameRegExp)) continue;
				this.advice(propertyName, advice, null);				
			}			
			return this;
		}
		,
		after : function(methodName, advice) {
			
			if (methodName instanceof String) {
				methodName = new RegExp(methodName);
			}
			
			for (var propertyName in _object) {
				if (!propertyName.match(methodName)) continue;
				this.advice(propertyName, null, advice);				
			}			
			return this;
		}
		,
		around : function(methodName, advice) {
						
			if (methodName instanceof String) {
				methodName = new RegExp(methodName);
			}
			
			for (var propertyName in _object) {
				if (!propertyName.match(methodName)) continue;
				var property = _object[propertyName];
				
				_object[propertyName] = function() {
					var args = arguments;
					var that = this;
					function pointcut() {
						return property.apply(that, args);
					}
					return advice.call(this, pointcut)
				}
			}			
			return this;
		}
	}
}

var o = {
	m1 : function(a1, a2) {
		console.log(a1, a2);
		return a1;
	}
	,
	m2 : function(a1, a2) {
		console.log(a1, a2);
		return a2;
	}
}

Aspect(o).around("m1", function(pointcut) {
	console.log("before m1");
	var result = pointcut();
	console.log("after m1");
	return result;
});

Aspect(o).around("m2", function(pointcut) {
	console.log("before m2");
	var result = pointcut();
	console.log("after m2");
	return result;
});


o.m1(1,2);
o.m2(1,2);

</script>