<script>

/*
// OBJECT concept
- Has assotiated VAO and UAO that are applied to any program within
- elements array
- first and count
- draw mode 
- Can have one or more 'methods' that are programs
- Can be 'abstract' and extended
- Every method is passed it's output (textures, depthBuffer)

o3gl.createObject().

// Entities
Geometry 
	VAO
	Elements
	first/last

Geometry Assembly
	Triangle
	Line
	Point
	
	
Rasterize
	inputs
		DepthTest
		StencilTest
		Blend 

	outputs
		FrameBuffer
			RenderBuffers 
				Color
				Depth
				Stencil
		
	Viewport
	glDrawMode
	

Program
	DepthTest
	StencilTest
	unitforms
	

// PIPELINE concept

Vertices > Vertex shader > Primitives generation > Rasterization > Fragment shader > Testing/Blending > Framebuffer
o3gl.pipeline().
	vertices(vertexShader).
		elements(buffer).
		set("a1", arrayBuffer.pointer()).
		set("a2", arrayBuffer.pointer()).
	rasterization(fragmentShader).
		first(0).count(6)
		modeTriangleFan()
		modePoints(pointSize)
		modeLines(lineWidth)
		
	
	primitivesGeneration().
	rasterization()
	
// DRAWCALL concept
o3gl.
	drawcall().
	program(program).
	vertexArrayObject(abo).
	frameBufferObject(fbo).
	set("a", vertexes).
	elements(buffer).
	drawTriangles().
	first(0).
	last(100).
	renderBufferColor(texture1, texture2).
	renderBufferDepth().
	depthTest(true).
	depthMask(true).
	viewport()
	

// IMPLICIT INSTANCING concept
Some of the chained methods produce a new program instance 

// EXPLICIT INSTANCING concept
Explicit program instance creation
*/

/**
TODO:

- hints sucks. must be changed to inheritance or some kind of builder pattern

	
- Program instancing
	- Program globals are bound to program and used implicitly (if set)
		- Global uniforms (default) (implemented by default)
		- Global attributes (default) (implemented)
			- Shortcut (VAO) lazy initialization methods (Set, AttributeXX, VertexAttributeXX,  VertexAttributePointer)
		- Global FrameBufferObject
			- Shortcut (FBO) lazy initialization methods (Set, AttributeXX, VertexAttributeXX,  VertexAttributePointer)

	- Instancing implies usage of global values that are substituted when new value is assigned
		- Uniform Buffer Object (per instance)		
		- Vertex Array Objects (per instance)		
		- FrameBufferObject (per instance). 		Do we really need it???
		
	- Internally generated resources (It is likely a bad idea, can have problems with configuration !!! )
		- Deleted when the program resource is deleted
		- Both for globals and in
		- textures, (sampler2D/samplerCube), )

	- Embedded matrix operations
		```
			mat4.identity(matrixM);
			mat4.translate(matrixM, [x * step, y * step, z * step]);			
			mat4.multiply(matrixV, matrixM , matrixMV);
			mat4.toInverseMat3(matrixMV, matrixN);
			mat3.transpose(matrixN);
			programPhong.
				Set("uMatrixV", 	matrixV). 		
				Set("uMatrixP", 	matrixP).		
				Set("uMatrixM", 	matrixM).
				Set("uMatrixN", 	matrixN).
		```
		```
			// Internal stack
			programPhong.matrix("uMatrixV").identity().lookat();
			programPhong.matrix("uMatrixM").identity().translate(1, 0, 0);
			programPhong. matrix("uMatrixV").multiply("uMatrixM").toInverseMat3().transpose().Set("uMatrixN");
		```
		
	
- aspects

	- layered concept (based on aspects)
		- client state tracking. Automatic `Use` and `Bind` methods invokation
		- or deffered methods that are used right after `Use` or `Bind` methods invoked. this allows configuration reordering. The cases are:
			- Any ideas???

		
- methods and variables naming convention


- Inline compillation / scripts generation. Killer feature!

*/

/**
program.VertexArray(); 				// return default
program.VertexArray(customVAO); 		// set up new
program.FrameBuffer();				// default frame buffer
program.FrameBuffer(null);				// default frame buffer
program.FrameBuffer(custom FBO);		// default frame buffer

program.FrameBuffer().Color(texture0, texture1);
program.FrameBuffer().Depth(texture2);		// Depth texture extension
program.FrameBuffer().Stencil(rbDepth);		// Depth texture extension DepthMask(true)
program.FrameBuffer().Clear(); // Clear all the assotiated buffers

program.FrameBuffer().ClearColor(0,0,0,1);
program.FrameBuffer().ClearColor(false);
program.FrameBuffer().ClearDepth(1.0);
program.FrameBuffer().ClearDepth(false);
program.FrameBuffer().Clear();					// By default clears all the assotiated render buffers with the default value. 
program.FrameBuffer().ClearColorBuffer();		
program.FrameBuffer().ClearDepthBuffer();
program.FrameBuffer().ClearStencilBuffer();

program.DepthTest(true);		// Depth test and mask are program-specific features
program.DepthMask(true);		// Depth test and mask are program-specific features 
*/

/*
rbDepth.Clear();
textureColor.Clear();

instance.FrameBuffer().Color(textureColor).Depth(rbDepth).Clear();


*/

/*
*/

/**
UBO extension
var ubo = o3gl.createUniformBuffer();

var ubs = program.GetUniformBlockSize();
ubo.Data(ubs); // allocate data for all blocks

program.uniformBlock(name, ubo.pointer().size(ubs).offset(100 * ubs)); // Bind particular uniform block

program.uniformBlock(name1,name2, ubo.pointer()); // Bind sequential uniform blocks

// Subsequent calls of uniformxxx methods will change 


ubo.pointer().set(program, name)	// set up offset, type (if name points to a uniform variable), size ()
ubo.pointer().set(program, name)	// set up offset, type (if name points to a uniform variable)



*/



/*
// BLEND, DEPTH, Clear

program.Blend(false); // 
program.Blend(true); // Default is 
program.BlendFunc(BlendFactor.SrcAlpha, BlendFactor.One); // Same as program.Blend(true)

program.BlendSourceFactor(BlendFactor.SrcAlpha, BlendFactor.One); // Same as program.Blend(true)

program.DepthMask().DepthTest()


// Draw 
program.Blend(true)
program.DepthTest(true).DepthMask(false)


// Blend, BlendFunc DepthMask, DepthTest, Viewport, ClearColor, ClearDepth, program bindings must trigger default settings for other programs ??? 
// Push/Pop changed states ???
*/



/**
ACCESSORS

var texture = 
var pi = program.newInstance();

pi.FrameBuffer = fb;
pi.FrameBuffer.Color = [];
pi.FrameBuffer.Depth = [];
pi.FrameBuffer.Stencil = [];
pi.Viewport = [0, 0, 100, 100]


pi.aPosition = ab.pointer();
pi.uMatrixM = matrix;
*/


/*
// External matricies:
mat4.identity(matrixM);
mat4.translate(matrixM, [ (i - 1) * 3 , (j - 1) * 3 , 0]);
mat4.multiply(matrixM,matrixRotation, matrixM);

mat4.identity(matrixMV);
mat4.multiply(matrixM, matrixMV, matrixMV);
mat4.multiply(matrixV, matrixMV, matrixMV);				
mat4.toInverseMat3(matrixMV, matrixN);
mat3.transpose(matrixN);

program.
	Set("uMatrixM", 		matrixM).
	Set("uMatrixN", 		matrixN).
	DrawTriangles();

o3gl.matrix()
	
// Builtin matrix
program.
	matrix("uMatrixM").identity().translate([1,0,0]).multiply(matrixRotation)
	Identity("uMatrixM").Translate()
	


	
	
	
*/


</script>