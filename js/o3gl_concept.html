<script>

/*
// OBJECT concept
- Has assotiated VAO and UAO that are applied to any program within
- elements array
- first and count
- draw mode 
- Can have one or more 'methods' that are programs
- Can be 'abstract' and extended
- Every method is passed it's output (textures, depthBuffer)

o3gl.createObject().

// Entities
Geometry 
	VAO
	Elements
	first/last

Geometry Assembly
	Triangle
	Line
	Point
	
	
Rasterize
	inputs
		DepthTest
		StencilTest
		Blend 

	outputs
		FrameBuffer
			RenderBuffers 
				Color
				Depth
				Stencil
		
	Viewport
	glDrawMode
	

Program
	DepthTest
	StencilTest
	unitforms
	

// PIPELINE concept

Vertices > Vertex shader > Primitives generation > Rasterization > Fragment shader > Testing/Blending > Framebuffer
o3gl.pipeline().
	vertices(vertexShader).
		elements(buffer).
		set("a1", arrayBuffer.pointer()).
		set("a2", arrayBuffer.pointer()).
	rasterization(fragmentShader).
		first(0).count(6)
		modeTriangleFan()
		modePoints(pointSize)
		modeLines(lineWidth)
		
	
	primitivesGeneration().
	rasterization()
	
// DRAWCALL concept
o3gl.
	drawcall().
	program(program).
	vertexArrayObject(abo).
	frameBufferObject(fbo).
	set("a", vertexes).
	elements(buffer).
	drawTriangles().
	first(0).
	last(100).
	renderBufferColor(texture1, texture2).
	renderBufferDepth().
	depthTest(true).
	depthMask(true).
	viewport()
	

// IMPLICIT INSTANCING concept
Some of the chained methods produce a new program instance 

// EXPLICIT INSTANCING concept
Explicit program instance creation
*/

/**
TODO:

- hints sucks. must be changed to inheritance or some kind of builder pattern

	
- Program instancing
	- Program globals are bound to program and used implicitly (if set)
		- Global uniforms (default) (implemented by default)
		- Global attributes (default) (implemented)
			- Shortcut (VAO) lazy initialization methods (Set, AttributeXX, VertexAttributeXX,  VertexAttributePointer)
		- Global FrameBufferObject
			- Shortcut (FBO) lazy initialization methods (Set, AttributeXX, VertexAttributeXX,  VertexAttributePointer)

	- Instancing implies usage of global values that are substituted when new value is assigned
		- Uniform Buffer Object (per instance)		
		- Vertex Array Objects (per instance)		
		- FrameBufferObject (per instance). 		Do we really need it???
		
	- Internally generated resources (It is likely a bad idea, can have problems with configuration !!! )
		- Deleted when the program resource is deleted
		- Both for globals and in
		- textures, (sampler2D/samplerCube), )

	- Embedded matrix operations
		```
			mat4.identity(matrixM);
			mat4.translate(matrixM, [x * step, y * step, z * step]);			
			mat4.multiply(matrixV, matrixM , matrixMV);
			mat4.toInverseMat3(matrixMV, matrixN);
			mat3.transpose(matrixN);
			programPhong.
				Set("uMatrixV", 	matrixV). 		
				Set("uMatrixP", 	matrixP).		
				Set("uMatrixM", 	matrixM).
				Set("uMatrixN", 	matrixN).
		```
		```
			// Internal stack
			programPhong.matrix("uMatrixV").identity().lookat();
			programPhong.matrix("uMatrixM").identity().translate(1, 0, 0);
			programPhong. matrix("uMatrixV").multiply("uMatrixM").toInverseMat3().transpose().Set("uMatrixN");
		```
		
	
- aspects

	- layered concept (based on aspects)
		- client state tracking. Automatic `Use` and `Bind` methods invokation
		- or deffered methods that are used right after `Use` or `Bind` methods invoked. this allows configuration reordering. The cases are:
			- Any ideas???

		
- methods and variables naming convention


- Inline compillation / scripts generation. Killer feature!

*/

/**
program.VertexArray(); 				// return default
program.VertexArray(customVAO); 		// set up new
program.FrameBuffer();				// default frame buffer
program.FrameBuffer(null);				// default frame buffer
program.FrameBuffer(custom FBO);		// default frame buffer

program.FrameBuffer().Color(texture0, texture1);
program.FrameBuffer().Depth(texture2);		// Depth texture extension
program.FrameBuffer().Stencil(rbDepth);		// Depth texture extension DepthMask(true)
program.FrameBuffer().Clear(); // Clear all the assotiated buffers

program.FrameBuffer().ClearColor(0,0,0,1);
program.FrameBuffer().ClearColor(false);
program.FrameBuffer().ClearDepth(1.0);
program.FrameBuffer().ClearDepth(false);
program.FrameBuffer().Clear();					// By default clears all the assotiated render buffers with the default value. 
program.FrameBuffer().ClearColorBuffer();		
program.FrameBuffer().ClearDepthBuffer();
program.FrameBuffer().ClearStencilBuffer();

program.DepthTest(true);		// Depth test and mask are program-specific features
program.DepthMask(true);		// Depth test and mask are program-specific features 
*/

/**
UBO extension
var ubo = o3gl.createUniformBuffer();

var ubs = program.GetUniformBlockSize();
ubo.Data(ubs); // allocate data for all blocks

program.uniformBlock(name, ubo.pointer().size(ubs).offset(100 * ubs)); // Bind particular uniform block

program.uniformBlock(name1,name2, ubo.pointer()); // Bind sequential uniform blocks

// Subsequent calls of uniformxxx methods will change 


ubo.pointer().set(program, name)	// set up offset, type (if name points to a uniform variable), size ()
ubo.pointer().set(program, name)	// set up offset, type (if name points to a uniform variable)



*/



/*
// BLEND, DEPTH, Clear

program.Blend(false); // 
program.Blend(true); // Default is 
program.BlendFunc(BlendFactor.SrcAlpha, BlendFactor.One); // Same as program.Blend(true)

program.BlendSourceFactor(BlendFactor.SrcAlpha, BlendFactor.One); // Same as program.Blend(true)

program.DepthMask().DepthTest()


// Draw 
program.Blend(true)
program.DepthTest(true).DepthMask(false)


// Blend, BlendFunc DepthMask, DepthTest, Viewport, ClearColor, ClearDepth, program bindings must trigger default settings for other programs ??? 
// Push/Pop changed states ???
*/


/**
Currying aspect
*/

function Deffered(src, dst, methodNameRegexp) {
	var result = {};

	function DefferedMethod(src, dst, methodName) {
		var method = src[methodName];
		dst[methodName] = function() {
			var args = arguments;
			var that = src;
			result[methodName] = function() {
				method.apply(that, args);
			}
		}
	}
	
	for (var name in src) {
		if (name.match(methodNameRegexp)) {
			DefferedMethod(src, dst, name);
		}
	}
	
	return function() {
		for (var name in result) {
			var defferedMethod = result[name];
			if (this) {
				defferedMethod.call(this);
			} else {
				defferedMethod(this);
			}
		}
	}
}


var o1 = {
	value : 0
	,
	f1 : function(value) {
		this.value = value;
		console.log(value);
	}
	,
	f2 : function(value) {
		this.value = value;
		console.log(value);
	}
	,
	f3 : function(value) {
		this.value = value;
		console.log(value);
	}
}
var o2 = {}
var deffered = Deffered(o1, o2, /f2|f1|f3/);
o1.f1(1);
o2.f3(3);
o2.f2(2);

console.log(o1.value);
deffered();
console.log(o1.value);

</script>