<html>

<head>
<title>Post-process god rays example</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<!--
<script type="text/javascript" src="jquery-1.4.2.min.js"></script>
-->
<script type="text/javascript" src="stats.min.js"></script>
<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="../o3gl.js"></script>
<script type="text/javascript" src="../shaders/phong.js"></script>
<script type="text/javascript" src="../shaders/postprocess.js"></script>
<script type="text/javascript" src="../utils/utils.js"></script>
<script type="text/javascript" src="../utils/primitives.js"></script>


<style type='text/css'>    
	html, body {
		width:  100%;
		height: 100%;
		margin: 0px;
	}
</style>

<script type="text/javascript">
    var gl;	
	var angle = 0;
	
	// Referenced by the shader program variables
	var viewport 			= {};
	var matrixM 		= mat4.create();
	var matrixV 		= mat4.create();
	var matrixMV 		= mat4.create();
	var matrixP 		= mat4.create();
	var matrixN 		= mat3.create();
	var blurCenter		= [0.5, 0.5];
	
	var diffuse		= [0.0, 0.0, 0.0, 1.0];
	var ambient		= [0.0, 0.0, 0.0, 1.0];
	var specular	= [1.0, 1.0, 1.0, 1.0];
	
	var useBufferTexture;
	var initGeometry;
	var drawGeometry;
	var postProcess;

	function init() {				
		var materialDiffuse 	= [0.5, 0.5, 0.5, 1.0];
		var materialSpecular 	= [1.0, 1.0, 1.0, 1.0];
		var materialAmbient 	= [0.0, 0.0, 0.0, 1.0];

		window.onresize();
		// Initialize matrices
		mat4.identity(matrixV);
		mat4.translate(matrixV, [0,0,-5]);
		mat4.identity(matrixM);
		mat4.identity(matrixMV);
		
		// Use render to texture
		var bufferDepth 		= new RenderBufferDepth(viewport.width, viewport.height);
		
		// Deffered rendering
		var texturePosition 	= new Texture2D(viewport.width, viewport.height).typeFloat();
		var textureDiffuse 		= new Texture2D(viewport.width, viewport.height);
		var textureSpecular 	= new Texture2D(viewport.width, viewport.height);
		var textureNormal 		= new Texture2D(viewport.width, viewport.height);
		
		var cube 		= new Cube(32,32);

		// Configure render buffer
		
		useBufferTexture = new Program().
		viewport(viewport).
		enableDepthTest(true).
		frameBuffer(new FrameBuffer().texture2D(textureMain).renderBuffer(bufferDepth)).
		clearColor([0.0, 0.0, 0.0, 1.0]).clearColorBuffer().clearDepthBuffer();

		useBufferTextureOcl = new Program().
		frameBuffer(new FrameBuffer().texture2D(textureOcclusion).renderBuffer(bufferDepth)).
		viewport(viewport).
		clearColor([0.0, 0.0, 0.0, 1.0]).clearColorBuffer(). // do not clear depth buffer
		enableDepthTest(true);
		
		initGeometry = Shaders.Phong.exclude(
			"aDiffuse","aAmbient","aSpecular", 
			"uSamplerCube",	
			//"uMaterialDiffuse",
			//"uMaterialSpecular",
			//"uMaterialAmbient",
			"uSamplerNormal",
			"uSamplerDiffuse",
			"uSamplerSpecular",			
			"uSamplerAmbient"
		).get().
		useProgram().
		vertexAttribPointer("aPosition", 		new ArrayBuffer.Float32(cube.positions).setSize(3)).
		vertexAttribPointer("aNormal", 			new ArrayBuffer.Float32(cube.normals).setSize(3)).
		uniformf("uLightPosition", 				0.0, 0.0, 0.0).
		uniformMatrix4fv("uMatrixP", 	matrixP);
		
		// Assign dynamic properties
		drawGeometry = new Program(initGeometry).
			uniformf("uMaterialDiffuse", 	diffuse).
			uniformf("uMaterialSpecular", 	specular).
			uniformf("uMaterialAmbient", 	ambient).
			uniformMatrix4fv("uMatrixM", 	matrixM).
			uniformMatrix4fv("uMatrixV", 	matrixV).
			uniformMatrix3fv("uMatrixN", 	matrixN).
			drawElementsTriangles(new ArrayBuffer.Uint16(cube.indexes));
				
		var plane 				= new Plane2D(); // Post-process plane
		var planePositions 		= new ArrayBuffer.Float32(plane.positions).setSize(2);
		var planeTextureCoords 	= new ArrayBuffer.Float32(plane.textureCoords).setSize(2);
		
		var blurSize = viewport.width / 2;
		var blur = Shaders.Convolution.get().
			useProgram().
			vertexAttribPointer("aPosition", 	planePositions).
			vertexAttribPointer("aTextureCoord", planeTextureCoords).
			// First pass (horizontal)
			uniformf("uTexelStep", 1/blurSize, 0).							// Horizontal
			uniformTexture2D("uSampler0", textureOcclusion).					// Source texture (our frame buffer)
			frameBuffer(new FrameBuffer().texture2D(textureBlured)).			// Destination texture
			drawArraysTriangles(0, 6).										// Render the first pass
			// Second pass (vertical)
			uniformf("uTexelStep", 0, 1/blurSize * viewport.aspect).		// Vertical
			uniformTexture2D("uSampler0", textureBlured).				// Source texture
			drawArraysTriangles(0, 6);										// Render the second pass
		
		var godray = Shaders.RadialBlur.get().
			useProgram().
			vertexAttribPointer("aPosition", 	planePositions).
			vertexAttribPointer("aTextureCoord", planeTextureCoords).
			uniformTexture2D("uSampler0", textureBlured).				
			uniformf("uCenter", blurCenter).				
			frameBuffer(new FrameBuffer().texture2D(textureGodRay)).		
			drawArraysTriangles(0, 6);


		var blend = Shaders.BlendAdditive.get().
			useProgram().
			vertexAttribPointer("aPosition", 	planePositions).
			vertexAttribPointer("aTextureCoord", planeTextureCoords).
			uniformTexture2D("uSampler0", textureMain).
			uniformTexture2D("uSampler1", textureGodRay).
			frameBuffer(null).
			drawArraysTriangles(0, 6);

		var flush = new PostProcess().get().
			useProgram().
			vertexAttribPointer("aPosition", 	planePositions).
			vertexAttribPointer("aTextureCoord", planeTextureCoords).
			uniformTexture2D("uSampler0", textureMain).
			frameBuffer(null).
			drawArraysTriangles(0, 6);

			
		programPostProcess = new Program().			
		enableDepthTest(false).
		viewport(0, 0, viewport.width, viewport.height).
		push(flush);
//		push(blur).
//		push(godray).
//		push(blend);
	}
	
	function render() {
		initGeometry.run();
		useBufferTexture.run();
		
		// Draw regular geometry
		var step = 2.5;
		for (var x=-1; x <= 1; x ++) 
		for (var y=-1; y <= 1; y ++)
		for (var z=-1; z <= 1; z ++) 
		{
			if (x === 0 && y === 0 && z === 0) continue;
			mat4.identity(matrixM);
			mat4.translate(matrixM, [x * step, y * step, z * step]);
			mat4.multiply(matrixV, matrixM , matrixMV);
			mat4.toInverseMat3(matrixMV, matrixN);
			mat3.transpose(matrixN);

			specular[0] 	= 0.1;
			specular[1] 	= 0.1;
			specular[2] 	= 0.1;
			ambient[0] 		= 0.0;
			ambient[1] 		= 0;
			ambient[2] 		= 0;
			var r = (x + 1) / 2;
			var g = (y + 1) / 2;
			var b = (z + 1) / 2;
			diffuse[0] 		= r;
			diffuse[1] 		= g;
			diffuse[2] 		= b;
			
			drawGeometry.run();
		}
		
		// Draw god ray emissing geometry to the separate buffer
		useBufferTextureOcl.run();
		mat4.identity(matrixM);
		mat4.translate(matrixM, [0, 0, 0]);
		mat4.multiply(matrixV, matrixM , matrixMV);
		mat4.toInverseMat3(matrixMV, matrixN);
		mat3.transpose(matrixN);
		specular[0] 	= 0;
		specular[1] 	= 0;
		specular[2] 	= 0;
		ambient[0] 		= 1.0;
		ambient[1] 		= 1.0;
		ambient[2] 		= 1.0;
		diffuse[0] 		= 1.0;
		diffuse[1] 		= 0;
		diffuse[2] 		= 0;
		drawGeometry.run();
		
		// Compose effects
		programPostProcess.run();
    }
    
    function update() {
		angle += 0.01;
		stats.begin();
		render();
		stats.end();
		requestAnimFrame(update)
    }

    function webGLStart() {	
		stats = new Stats();
		stats.setMode(0); // 0: fps, 1: ms
		// Align top-left
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.left = '0px';
		stats.domElement.style.top = '0px';

		document.body.appendChild( stats.domElement );
	
        var canvas = document.getElementById("canvas");
		gl = WebGLUtils.setupWebGL(canvas);
		init();
        update();
		
		var r = mat4.create();
		mat4.identity(r);
		addMouseListener(function (dx, dy, lb, rb, mb) {
			mat4.rotate(r, 0.05, [-dy, -dx, 0]);
			mat4.identity(matrixV);
			mat4.translate(matrixV, [0,0,-10]);
			mat4.multiply(matrixV, r, matrixV);
		}) ;
    }
	
	window.onresize = function() {
		gl.canvas.width  = document.body.clientWidth;
		gl.canvas.height = document.body.clientHeight;			
		viewport.x 		= 0;
		viewport.y 		= 0;
		viewport.width 	= gl.canvas.width;
		viewport.height = gl.canvas.height;
		viewport.aspect = viewport.width / viewport.height;
		mat4.frustum(-1,1,-1/viewport.aspect,1/viewport.aspect,1,20, matrixP)
	}
	
	function addMouseListener(listener) {
		var x;
		var y;
		var isMouseDown = false;
		addEventListener("mousemove", function(e) {
			if (isMouseDown) {
				listener(e.clientX - x, e.clientY - y);
				x = e.clientX;
				y = e.clientY;
			}
		}); 
		
		addEventListener("mousedown", function(e) {
			isMouseDown = true;
		}); 

		addEventListener("mouseup", function(e) {
			isMouseDown = false;
		});
	
	}
	
</script>


</head>


<body onload="webGLStart();" style="overflow: hidden">
	<div>
		<canvas id="canvas" style="border: none; margin:0; padding:0; " width="300" height="300"></canvas>
	</div>
</body>

</html>
