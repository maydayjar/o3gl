<html>

<head>
<title>Volumetric shadow postprocess example</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<!--
<script type="text/javascript" src="jquery-1.4.2.min.js"></script>
-->
<script type="text/javascript" src="stats.min.js"></script>
<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="../o3gl.js"></script>
<script type="text/javascript" src="../shaders/phong.js"></script>
<script type="text/javascript" src="../shaders/postprocess.js"></script>
<script type="text/javascript" src="../utils/utils.js"></script>
<script type="text/javascript" src="../utils/primitives.js"></script>


<style type='text/css'>    
	html, body {
		width:  100%;
		height: 100%;
		margin: 0px;
	}
</style>

<script type="text/javascript">
    var gl;	
	var angle = 0;
	
	// Referenced by the shader program variables
	var viewport 			= {};
	var matrixM 		= mat4.create();
	var matrixV 		= mat4.create();
	var matrixMV 		= mat4.create();
	var matrixP 		= mat4.create();
	var matrixN 		= mat3.create();
	var blurCenter		= [0.0, 0.0, 0.0, 0.0];
	
	var light		= [0.0, 0.0, 0.0];
	
	var diffuse		= [0.0, 0.0, 0.0, 1.0];
	var ambient		= [0.0, 0.0, 0.0, 1.0];
	var specular	= [1.0, 1.0, 1.0, 1.0];
	
	var useBufferColor;
	var useBufferDepth;
	
	var initColor;
	var drawColor;
	var initDepth;
	var drawDepth;
	
	var postProcess;
	
	function init() {				
		var materialDiffuse 	= [0.5, 0.5, 0.5, 1.0];
		var materialSpecular 	= [1.0, 1.0, 1.0, 1.0];
		var materialAmbient 	= [0.0, 0.0, 0.0, 1.0];

		window.onresize();

		// Initialize matrices
		mat4.identity(matrixV);
		mat4.translate(matrixV, [0,0,-20]);
		mat4.identity(matrixM);
		mat4.identity(matrixMV);
		
		// Use render to texture
		var textureDiffuse 	= new Texture2D(viewport.width, viewport.height);
		var textureDepth 	= new Texture2D(viewport.width, viewport.height);
		var textureBlured = new Texture2D(viewport.width / 2, viewport.height / 2);
		var textureGodRay = new Texture2D(viewport.width / 2, viewport.height / 2);

		// Configure render buffer
		
		useBufferColor = new Program().
		viewport(viewport).
		enableDepthTest(true).
		frameBuffer(new FrameBuffer().texture2D(textureDiffuse).renderBuffer(new RenderBufferDepth(viewport.width, viewport.height))).
		clearColor([1.0, 1.0, 1.0, 1.0]).clearColorBuffer().clearDepthBuffer();

		useBufferDepth = new Program().
		frameBuffer(new FrameBuffer().texture2D(textureDepth).renderBuffer(new RenderBufferDepth(viewport.width, viewport.height))).
		viewport(viewport).
		clearColor([1.0, 1.0, 1.0, 1.0]).clearColorBuffer().clearDepthBuffer().
		enableDepthTest(true);
		
		var cube 		= new Cube(32,32);
		
		initColor = Shaders.Phong.exclude(
			"aDiffuse","aAmbient","aSpecular", 
			"uSamplerCube",	
			//"uMaterialDiffuse",
			//"uMaterialSpecular",
			//"uMaterialAmbient",
			"uSamplerNormal",
			"uSamplerDiffuse",
			"uSamplerSpecular",			
			"uSamplerAmbient"
		).get();
		initColor.
			useProgram().
			attribute3f("aPosition", new ArrayBuffer(cube.positions)).
			uniformMatrix4fv("uMatrixV", 	matrixV). 		// View transformation
			uniformMatrix4fv("uMatrixP", 	matrixP).		// Projection transformation
			attribute3f("aNormal", 	new ArrayBuffer(cube.normals)).
			uniformf("uLightPosition", 		light);
		drawColor = new Program(initColor).
			uniformMatrix4fv("uMatrixM", 	matrixM).
			uniformMatrix3fv("uMatrixN", 	matrixN).
			uniformf("uMaterialDiffuse", 	diffuse).
			uniformf("uMaterialSpecular", 	specular).
			uniformf("uMaterialAmbient", 	ambient).
			drawElementsTriangles(new ArrayBuffer(cube.indexes).typeUnsignedShort(1));
			
		initDepth = Shaders.DepthRGB.get();
		initDepth.
			useProgram().
			attribute3f("aPosition", new ArrayBuffer(cube.positions)).
			uniformMatrix4fv("uMatrixV", 	matrixV). 		// View transformation
			uniformMatrix4fv("uMatrixP", 	matrixP);		// Projection transformation
		drawDepth = new Program(initDepth).
			uniformMatrix4fv("uMatrixM", 	matrixM).
			drawElementsTriangles(new ArrayBuffer(cube.indexes).typeUnsignedShort(1));
		
		// Configure post process
		var plane 				= new Plane2D(); // Post-process plane
		var planePositions 		= new ArrayBuffer(plane.positions);
		var planeTextureCoords 	= new ArrayBuffer(plane.textureCoords);

		var blur 	= Shaders.Convolution.get();
		var godray 	= Shaders.BlurRadial.get();
		var blend 	= Shaders.BlendMultiply.get();
		var flush 	= new PostProcess().get();

		var blurSize = viewport.width / 2;
		blur.
			useProgram().
			attribute2f("aPosition", 	planePositions).
			attribute2f("aTextureCoord", planeTextureCoords).
			frameBuffer(new FrameBuffer().texture2D(textureBlured)).		// Destination texture
			// First pass (horizontal)
			uniformf("uTexelStep", 1/blurSize, 0).							// Horizontal
			uniformTexture("uSampler0", textureDepth).					// Source texture (our frame buffer)
			drawArraysTriangles(0, 6).										// Render the first pass
			// Second pass (vertical)
			uniformf("uTexelStep", 0, 1/blurSize * viewport.aspect).		// Vertical
			uniformTexture("uSampler0", textureBlured).				// Source texture
			drawArraysTriangles(0, 6);										// Render the second pass

		godray.
			useProgram().
			attribute2f("aPosition", 	planePositions).
			attribute2f("aTextureCoord", planeTextureCoords).
			uniformf("uOrigin", blurCenter).				
			uniformf("uStep", 1.0 / 128.0).				
			uniformTexture("uSampler0", textureDiffuse).				
			frameBuffer(new FrameBuffer().texture2D(textureGodRay)).		
			drawArraysTriangles(0, 6);
		
		/*
		// HQ blur
		godray.
			uniformTexture("uSampler0", textureGodRay).				
			frameBuffer(new FrameBuffer().texture2D(textureBlured)).		
			drawArraysTriangles(0, 6).
			uniformTexture("uSampler0", textureBlured).				
			frameBuffer(new FrameBuffer().texture2D(textureGodRay)).		
			drawArraysTriangles(0, 6);
		*/
		
		blend.
			useProgram().
			attribute2f("aPosition", 	planePositions).
			attribute2f("aTextureCoord", planeTextureCoords).
			frameBuffer(null).
			uniformTexture("uSampler0", textureDiffuse).
			uniformTexture("uSampler1", textureGodRay).
			drawArraysTriangles(0, 6);
		var flush = new PostProcess().get().
			useProgram().
			attribute2f("aPosition", 	planePositions).
			attribute2f("aTextureCoord", planeTextureCoords).
			uniformTexture("uSampler0", textureGodRay).
			frameBuffer(null).
			drawArraysTriangles(0, 6);
			
		programPostProcess = new Program().			
		enableDepthTest(false).
		viewport(0, 0, viewport.width, viewport.height).
		push(blur).
		push(godray).
		push(flush);
//		push(blend);
	}
	
	function render() {
		
		// Update projection matrix
		mat4.frustum(-1,1,-1/viewport.aspect,1/viewport.aspect,1,30, matrixP);
		
		// Draw regular geometry
		initColor.run();
		useBufferColor.run();
		var step = 2.5;
		for (var x=-1; x <= 1; x ++) 
		for (var y=-1; y <= 1; y ++)
		for (var z=-1; z <= 1; z ++) 
		{
			mat4.identity(matrixM);
			mat4.translate(matrixM, [x * step, y * step, z * step]);
			mat4.multiply(matrixV, matrixM , matrixMV);
			mat4.toInverseMat3(matrixMV, matrixN);
			mat3.transpose(matrixN);

			specular[0] 	= 0.1;
			specular[1] 	= 0.1;
			specular[2] 	= 0.1;
			ambient[0] 		= 0.0;
			ambient[1] 		= 0;
			ambient[2] 		= 0;
			var r = (x + 1) / 2;
			var g = (y + 1) / 2;
			var b = (z + 1) / 2;
			diffuse[0] 		= r;
			diffuse[1] 		= g;
			diffuse[2] 		= b;			
			drawColor.run();
		}
		initDepth.run();
		useBufferDepth.run();
		var step = 2.5;
		for (var x=-1; x <= 1; x ++) 
		for (var y=-1; y <= 1; y ++)
		for (var z=-1; z <= 1; z ++) 
		{
			mat4.identity(matrixM);
			mat4.translate(matrixM, [x * step, y * step, z * step]);
			drawDepth.run();
		}
		
		// Compose effects
		programPostProcess.run();
    }
    
    function update() {
		angle += 0.01;
		stats.begin();
		render();
		stats.end();
		requestAnimFrame(update)
    }

    function webGLStart() {	
		stats = new Stats();
		stats.setMode(0); // 0: fps, 1: ms
		// Align top-left
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.left = '0px';
		stats.domElement.style.top = '0px';

		document.body.appendChild( stats.domElement );
	
        var canvas = document.getElementById("canvas");
		gl = WebGLUtils.setupWebGL(canvas);
		init();
        update();
		
		var r = mat4.create();
		mat4.identity(r);
		addMouseListener(function (dx, dy, lb, rb, mb) {
			mat4.rotate(r, 0.05, [-dy, -dx, 0]);
			mat4.identity(matrixV);
			mat4.translate(matrixV, [0,0,-20]);
			mat4.multiply(matrixV, r, matrixV);
		}) ;
    }
	
	window.onresize = function() {
		gl.canvas.width  = document.body.clientWidth;
		gl.canvas.height = document.body.clientHeight;			
		viewport.x 		= 0;
		viewport.y 		= 0;
		viewport.width 	= gl.canvas.width;
		viewport.height = gl.canvas.height;
		viewport.aspect = viewport.width / viewport.height;
	}
	
	function addMouseListener(listener) {
		var x;
		var y;
		var isMouseDown = false;
		addEventListener("mousemove", function(e) {
			if (isMouseDown) {
				listener(e.clientX - x, e.clientY - y);
				x = e.clientX;
				y = e.clientY;
			}
		}); 
		
		addEventListener("mousedown", function(e) {
			isMouseDown = true;
		}); 

		addEventListener("mouseup", function(e) {
			isMouseDown = false;
		});
	
	}
	
</script>


</head>


<body onload="webGLStart();" style="overflow: hidden">
	<div>
		<canvas id="canvas" style="border: none; margin:0; padding:0; " width="300" height="300"></canvas>
	</div>
</body>

</html>
