<html>

<head>
<title>Learning WebGL &mdash; lesson 16</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="webgl-debug.js"></script>
<script type="text/javascript" src="../o3gl.js"></script>

<script id="per-fragment-lighting-fs" type="x-shader/x-fragment">
	precision mediump float;

    varying vec2 vTextureCoord;
    varying vec3 vTransformedNormal;
    varying vec4 vPosition;

	uniform vec3 uMaterialAmbientColor;
    uniform vec3 uMaterialDiffuseColor;
    uniform vec3 uMaterialSpecularColor;
    uniform float uMaterialShininess;
    uniform vec3 uMaterialEmissiveColor;

    uniform bool uShowSpecularHighlights;
    uniform bool uUseTextures;

    uniform vec3 uAmbientLightingColor;

    uniform vec3 uPointLightingLocation;
    uniform vec3 uPointLightingDiffuseColor;
    uniform vec3 uPointLightingSpecularColor;

    uniform sampler2D uSampler;


    void main(void) {
        vec3 ambientLightWeighting = uAmbientLightingColor;

        vec3 lightDirection = normalize(uPointLightingLocation - vPosition.xyz);
        vec3 normal = normalize(vTransformedNormal);

        vec3 specularLightWeighting = vec3(0.0, 0.0, 0.0);
        if (uShowSpecularHighlights) {
            vec3 eyeDirection = normalize(-vPosition.xyz);
            vec3 reflectionDirection = reflect(-lightDirection, normal);

            float specularLightBrightness = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
            specularLightWeighting = uPointLightingSpecularColor * specularLightBrightness;
        }

        float diffuseLightBrightness = max(dot(normal, lightDirection), 0.0);
        vec3 diffuseLightWeighting = uPointLightingDiffuseColor * diffuseLightBrightness;

        vec3 materialAmbientColor = uMaterialAmbientColor;
        vec3 materialDiffuseColor = uMaterialDiffuseColor;
        vec3 materialSpecularColor = uMaterialSpecularColor;
        vec3 materialEmissiveColor = uMaterialEmissiveColor;
        float alpha = 1.0;
        if (uUseTextures) {
            vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
            materialAmbientColor = materialAmbientColor * textureColor.rgb;
            materialDiffuseColor = materialDiffuseColor * textureColor.rgb;
            materialEmissiveColor = materialEmissiveColor * textureColor.rgb;
            alpha = textureColor.a;
        }
        gl_FragColor = vec4(
            materialAmbientColor * ambientLightWeighting
            + materialDiffuseColor * diffuseLightWeighting
            + materialSpecularColor * specularLightWeighting
            + materialEmissiveColor,
            1.0
        );
    }
</script>

<script id="per-fragment-lighting-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;

    varying vec2 vTextureCoord;
    varying vec3 vTransformedNormal;
    varying vec4 vPosition;


    void main(void) {
        vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix * vPosition;
        vTextureCoord = aTextureCoord;
        vTransformedNormal = uNMatrix * aVertexNormal;
    }
</script>


<script type="text/javascript">

    var gl;

    function initGL(canvas) {
        try {
			//gl = WebGLDebugUtils.makeDebugContext(canvas.getContext("experimental-webgl"));

            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }
	var drawMoon, drawCube;
	var renderLaptopScreenImage;	
	var renderLaptopBody;
	var renderLaptop;
	
    function initShaders() {
		// Root shader program
		var shaderProgram = new Program(
			new VertexShader(document.getElementById("per-fragment-lighting-vs").textContent),
			new FragmentShader(document.getElementById("per-fragment-lighting-fs").textContent)
		);
		
		var setMatrixUniforms = new Program(shaderProgram);
		setMatrixUniforms.
		uniformMatrix4fv("uPMatrix", pMatrix).
		uniformMatrix4fv("uMVMatrix", mvMatrix).
		uniformMatrix3fv("uNMatrix", function() {
			var normalMatrix = mat3.create();
			mat4.toInverseMat3(mvMatrix, normalMatrix);
			mat3.transpose(normalMatrix);
			return normalMatrix;
		});
		
		// Render target texture
		var rttTexture = new Texture2D(512,512).magFilterLinear().minFilterLinearMipmapNearest().generateMipmap();
		// Subprograms
		drawMoon = new Program(shaderProgram).push(setMatrixUniforms);
		drawCube = new Program(shaderProgram).push(setMatrixUniforms);

		renderLaptopScreenImage = new Program(shaderProgram);
		renderLaptopScreenImage.
		useProgram().
		frameBuffer(new FrameBuffer().
			texture2D(rttTexture).
			renderBuffer(new RenderBufferDepth(512, 512))
		).
		viewport(0, 0, 512, 512).
		clearColorBuffer().clearDepthBuffer().
		uniformi("uUseTextures", true).
		uniformi("uShowSpecularHighlights", false).
		uniformf("uAmbientLightingColor", 0.2, 0.2, 0.2).
		uniformf("uPointLightingLocation", 0, 0, -5).
		uniformf("uPointLightingDiffuseColor", 0.8, 0.8, 0.8).
        uniformf("uMaterialAmbientColor", 1.0, 1.0, 1.0).
        uniformf("uMaterialDiffuseColor", 1.0, 1.0, 1.0).
        uniformf("uMaterialSpecularColor", 0.0, 0.0, 0.0).
        uniformf("uMaterialShininess", 0).
        uniformf("uMaterialEmissiveColor", 0.0, 0.0, 0.0).
		push(function() {
			// Initialize matricies
		    mat4.perspective(45, laptopScreenAspectRatio, 0.1, 100.0, pMatrix);
			mat4.identity(mvMatrix);
			mat4.translate(mvMatrix, [0, 0, -5]);
			mat4.rotate(mvMatrix, degToRad(30), [1, 0, 0]);
			
			mvPushMatrix();
			mat4.rotate(mvMatrix, degToRad(moonAngle), [0, 1, 0]);
			mat4.translate(mvMatrix, [2, 0, 0]);
			drawMoon.run();
			mvPopMatrix();
			
			mvPushMatrix();
			mat4.rotate(mvMatrix, degToRad(cubeAngle), [0, 1, 0]);
			mat4.translate(mvMatrix, [1.25, 0, 0]);
			drawCube.run();
			mvPopMatrix();
		});

		renderLaptopBody = new Program(shaderProgram);
		
		renderLaptop = new Program(shaderProgram);
		renderLaptop.
			useProgram().
			frameBuffer(null).
			viewport(0, 0, gl.viewportWidth, gl.viewportHeight).
			clearColorBuffer().clearDepthBuffer().
			// Update laptop transformations
			push(setMatrixUniforms).
			// Configure light
			uniformi("uShowSpecularHighlights", true).
			uniformf("uPointLightingLocation", -1, 2, -1).
			uniformf("uPointLightingDiffuseColor", 0.8, 0.8, 0.8).
			uniformf("uPointLightingSpecularColor", 0.8, 0.8, 0.8).
			// Render screen
			uniformi("uUseTextures", true).
			generateMipmap(rttTexture).
			uniformSampler("uSampler", rttTexture).
			uniformf("uAmbientLightingColor", 0.2, 0.2, 0.2).
			uniformf("uMaterialAmbientColor", 0.0, 0.0, 0.0).
			uniformf("uMaterialDiffuseColor", 0.0, 0.0, 0.0).
			uniformf("uMaterialSpecularColor", 0.5, 0.5, 0.5).
			uniformf("uMaterialShininess", 20).
			uniformf("uMaterialEmissiveColor", 1.5, 1.5, 1.5).
			attribute3f("aVertexPosition", laptopScreenVertexPositionBuffer).
			attribute3f("aVertexNormal", laptopScreenVertexNormalBuffer).
			attribute2f("aTextureCoord", laptopScreenVertexTextureCoordBuffer).
			drawArraysTriangleStrip(0, 4).
			// Render body
			uniformi("uUseTextures", false).
			uniformf("uAmbientLightingColor", 0.2, 0.2, 0.2).
			uniformf("uMaterialAmbientColor", 1.0, 1.0, 1.0).
			uniformf("uMaterialDiffuseColor", 1.0, 1.0, 1.0).
			uniformf("uMaterialSpecularColor", 1.5, 1.5, 1.5).
			uniformf("uMaterialShininess", 5).
			uniformf("uMaterialEmissiveColor", 0.0, 0.0, 0.0).
			push(renderLaptopBody); // Geometry rendering configuration is deffered. See handleLoadedLaptop() function
    }

    function initTextures() {
		var moon = new Image();
		moon.onload = function() {
			var crate = new Image();
			crate.onload = function() {
				drawMoon.
				uniformSampler("uSampler", 
					new Texture2D(moon).magFilterLinear().minFilterLinearMipmapNearest().generateMipmap()
				).
				attribute3f("aVertexPosition", moonVertexPositionBuffer).
				attribute3f("aVertexNormal", moonVertexNormalBuffer).
				attribute2f("aTextureCoord", moonVertexTextureCoordBuffer).
				drawElementsTriangles(moonVertexIndexBuffer);
				
				drawCube.
				uniformSampler("uSampler", 
					new Texture2D(crate).magFilterLinear().minFilterLinearMipmapNearest().generateMipmap()
				).
				attribute3f("aVertexPosition", cubeVertexPositionBuffer).
				attribute3f("aVertexNormal", cubeVertexNormalBuffer).
				attribute2f("aTextureCoord", cubeVertexTextureCoordBuffer).
				drawElementsTriangles(cubeVertexIndexBuffer);
			}
			crate.src = "crate.gif";
		}		
		moon.src = "moon.gif";
    }

    var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();

    function mvPushMatrix() {
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }

    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
		mat4.set(mvMatrixStack.pop(), mvMatrix);
    }

    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

    var cubeVertexPositionBuffer;
    var cubeVertexNormalBuffer;
    var cubeVertexTextureCoordBuffer;
    var cubeVertexIndexBuffer;

    var moonVertexPositionBuffer;
    var moonVertexNormalBuffer;
    var moonVertexTextureCoordBuffer;
    var moonVertexIndexBuffer;

    var laptopScreenVertexPositionBuffer;
    var laptopScreenVertexNormalBuffer;
    var laptopScreenVertexTextureCoordBuffer;

    function initBuffers() {
        cubeVertexPositionBuffer = new ArrayBuffer([
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,

            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,

            // Bottom face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,

            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,

            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0,
        ]);

        cubeVertexNormalBuffer = new ArrayBuffer([
            // Front face
             0.0,  0.0,  1.0,
             0.0,  0.0,  1.0,
             0.0,  0.0,  1.0,
             0.0,  0.0,  1.0,

            // Back face
             0.0,  0.0, -1.0,
             0.0,  0.0, -1.0,
             0.0,  0.0, -1.0,
             0.0,  0.0, -1.0,

            // Top face
             0.0,  1.0,  0.0,
             0.0,  1.0,  0.0,
             0.0,  1.0,  0.0,
             0.0,  1.0,  0.0,

            // Bottom face
             0.0, -1.0,  0.0,
             0.0, -1.0,  0.0,
             0.0, -1.0,  0.0,
             0.0, -1.0,  0.0,

            // Right face
             1.0,  0.0,  0.0,
             1.0,  0.0,  0.0,
             1.0,  0.0,  0.0,
             1.0,  0.0,  0.0,

            // Left face
            -1.0,  0.0,  0.0,
            -1.0,  0.0,  0.0,
            -1.0,  0.0,  0.0,
            -1.0,  0.0,  0.0,
        ]);

        cubeVertexTextureCoordBuffer = new ArrayBuffer([
            // Front face
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,

            // Back face
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,
            0.0, 0.0,

            // Top face
            0.0, 1.0,
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,

            // Bottom face
            1.0, 1.0,
            0.0, 1.0,
            0.0, 0.0,
            1.0, 0.0,

            // Right face
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,
            0.0, 0.0,

            // Left face
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0
        ]);

        cubeVertexIndexBuffer = new ArrayBuffer([
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ]);

        var latitudeBands = 30;
        var longitudeBands = 30;
        var radius = 1;

        var vertexPositionData = [];
        var normalData = [];
        var textureCoordData = [];
        for (var latNumber=0; latNumber <= latitudeBands; latNumber++) {
            var theta = latNumber * Math.PI / latitudeBands;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);

            for (var longNumber=0; longNumber <= longitudeBands; longNumber++) {
                var phi = longNumber * 2 * Math.PI / longitudeBands;
                var sinPhi = Math.sin(phi);
                var cosPhi = Math.cos(phi);

                var x = cosPhi * sinTheta;
                var y = cosTheta;
                var z = sinPhi * sinTheta;
                var u = 1 - (longNumber / longitudeBands);
                var v = 1 - (latNumber / latitudeBands);

                normalData.push(x);
                normalData.push(y);
                normalData.push(z);
                textureCoordData.push(u);
                textureCoordData.push(v);
                vertexPositionData.push(radius * x);
                vertexPositionData.push(radius * y);
                vertexPositionData.push(radius * z);
            }
        }

        var indexData = [];
        for (var latNumber=0; latNumber < latitudeBands; latNumber++) {
            for (var longNumber=0; longNumber < longitudeBands; longNumber++) {
                var first = (latNumber * (longitudeBands + 1)) + longNumber;
                var second = first + longitudeBands + 1;
                indexData.push(first);
                indexData.push(second);
                indexData.push(first + 1);

                indexData.push(second);
                indexData.push(second + 1);
                indexData.push(first + 1);
            }
        }

        moonVertexNormalBuffer = new ArrayBuffer(normalData);
        moonVertexTextureCoordBuffer = new ArrayBuffer(textureCoordData);
        moonVertexPositionBuffer = new ArrayBuffer(vertexPositionData);
        moonVertexIndexBuffer = new ArrayBuffer(indexData);
		
        laptopScreenVertexPositionBuffer = new ArrayBuffer([
             0.580687, 0.659, 0.813106,
            -0.580687, 0.659, 0.813107,
             0.580687, 0.472, 0.113121,
            -0.580687, 0.472, 0.113121,
        ]);
		laptopScreenVertexNormalBuffer = new ArrayBuffer([
             0.000000, -0.965926, 0.258819,
             0.000000, -0.965926, 0.258819,
             0.000000, -0.965926, 0.258819,
             0.000000, -0.965926, 0.258819,
        ]);
        laptopScreenVertexTextureCoordBuffer = new ArrayBuffer([
            1.0, 1.0,
            0.0, 1.0,
            1.0, 0.0,
            0.0, 0.0,
        ]);
    }

    function handleLoadedLaptop(laptopData) {
		// Append geometry rendering
		renderLaptopBody.
		attribute3f("aVertexPosition", new ArrayBuffer(laptopData.vertexPositions)).
		attribute3f("aVertexNormal", new ArrayBuffer(laptopData.vertexNormals)).
		attribute2f("aTextureCoord", new ArrayBuffer(laptopData.vertexTextureCoords)).
		drawElementsTriangles(new ArrayBuffer(laptopData.indices));
    }


    function loadLaptop() {
        var request = new XMLHttpRequest();
        request.open("GET", "macbook.json");
        request.onreadystatechange = function () {
            if (request.readyState == 4) {
                handleLoadedLaptop(JSON.parse(request.responseText));
            }
        }
        request.send();
    }



    var laptopScreenAspectRatio = 1.66;

    var moonAngle = 180;
    var cubeAngle = 0;
	
    var laptopAngle = 0;

    function drawScene() {
		// Run fully configured offscreen rendering
		renderLaptopScreenImage.run();
		// Configure matricies
        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
        mat4.identity(mvMatrix);
        mvPushMatrix();
        mat4.translate(mvMatrix, [0, -0.4, -2.2]);
        mat4.rotate(mvMatrix, degToRad(laptopAngle), [0, 1, 0]);
        mat4.rotate(mvMatrix, degToRad(-90), [1, 0, 0]);
		// Run default render target (screen) rendering
		renderLaptop.run();		
		mvPopMatrix();
    }


    var lastTime = 0;

    function animate() {
        var timeNow = new Date().getTime();
        if (lastTime != 0) {
            var elapsed = timeNow - lastTime;

            moonAngle += 0.05 * elapsed;
            cubeAngle += 0.05 * elapsed;

            laptopAngle -= 0.005 * elapsed;
        }
        lastTime = timeNow;
    }


    function tick() {
        requestAnimFrame(tick);
        drawScene();
        animate();
    }


    function webGLStart() {
        var canvas = document.getElementById("lesson16-canvas");
        initGL(canvas);
        initTextures();
        initBuffers();
        initShaders();
        loadLaptop();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

        tick();
    }

</script>


</head>


<body onload="webGLStart();">
    <a href="http://learningwebgl.com/blog/?p=1786">&lt;&lt; Back to Lesson 16</a><br />

    <canvas id="lesson16-canvas" style="border: none;" width="500" height="500"></canvas>
    <br/>

    Laptop model adapted from <a href="http://www.turbosquid.com/3d-models/apple-macbook-max-free/391534">this 3DS Max model by Xedium</a><br/>
    Moon texture courtesy of <a href="http://maps.jpl.nasa.gov/">the Jet Propulsion Laboratory</a>.
    <br/>
    <br/>

    <a href="http://learningwebgl.com/blog/?p=1786">&lt;&lt; Back to Lesson 16</a><br />
</body>

</html>
